-- Kurd hub - INSTANT STEAL (fully merged, smaller GUI, slightly slower teleports, more robust for high ping)
-- Notifications on toggle and prints removed. Rebirth notification text changed as requested.

if not game:IsLoaded() then game.Loaded:Wait() end

-- Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProximityPromptService = game:GetService("ProximityPromptService")
local Workspace = workspace
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- ======================
-- GUI (compact)
-- ======================

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SimpleGui"
screenGui.ResetOnSpawn = false
pcall(function() if syn and syn.protect_gui then syn.protect_gui(screenGui) end end)
screenGui.Parent = game.CoreGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 180, 0, 110) -- smaller size
mainFrame.Position = UDim2.new(0.5, -90, 0.45, -55)
mainFrame.BackgroundColor3 = Color3.fromRGB(12,12,12)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Selectable = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0,10)
frameCorner.Parent = mainFrame

local frameStroke = Instance.new("UIStroke")
frameStroke.Thickness = 1.5
frameStroke.Color = Color3.fromRGB(200,200,200)
frameStroke.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -8, 0, 28)
titleLabel.Position = UDim2.new(0, 4, 0, 6)
titleLabel.BackgroundTransparency = 1
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.Text = "DeathZ x Korez - INSTANT STEAL"
titleLabel.TextScaled = true
titleLabel.TextStrokeTransparency = 0.3
titleLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
titleLabel.TextXAlignment = Enum.TextXAlignment.Center
titleLabel.TextYAlignment = Enum.TextYAlignment.Center
titleLabel.Parent = mainFrame

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{ ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 0)) }
gradient.Rotation = 0
gradient.Parent = titleLabel

task.spawn(function() while task.wait(0.06) do gradient.Rotation = (gradient.Rotation + 3) % 360 end end)

local stealLabel = Instance.new("TextLabel")
stealLabel.Size = UDim2.new(0.55, -8, 0, 22)
stealLabel.Position = UDim2.new(0, 8, 0, 42)
stealLabel.BackgroundTransparency = 1
stealLabel.TextColor3 = Color3.new(1, 1, 1)
stealLabel.Font = Enum.Font.SourceSansBold
stealLabel.TextScaled = true
stealLabel.Text = "Instant Steal"
stealLabel.Parent = mainFrame

local toggleFrame = Instance.new("TextButton")
toggleFrame.Size = UDim2.new(0, 50, 0, 24) -- smaller toggle
toggleFrame.Position = UDim2.new(1, -64, 0, 40)
toggleFrame.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
toggleFrame.BorderSizePixel = 0
toggleFrame.AutoButtonColor = false
toggleFrame.Text = ""
toggleFrame.Parent = mainFrame

local tfCorner = Instance.new("UICorner")
tfCorner.CornerRadius = UDim.new(1,0)
tfCorner.Parent = toggleFrame

local knob = Instance.new("Frame")
knob.Size = UDim2.new(0, 20, 0, 20)
knob.Position = UDim2.new(0, 2, 0.5, -10)
knob.BackgroundColor3 = Color3.fromRGB(220, 220, 220)
knob.Parent = toggleFrame

local knobCorner = Instance.new("UICorner")
knobCorner.CornerRadius = UDim.new(1,0)
knobCorner.Parent = knob

local creditsLabel = Instance.new("TextLabel")
creditsLabel.Size = UDim2.new(1, -8, 0, 18)
creditsLabel.Position = UDim2.new(0, 4, 1, -26)
creditsLabel.BackgroundTransparency = 1
creditsLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
creditsLabel.Font = Enum.Font.GothamSemibold
creditsLabel.TextScaled = true
creditsLabel.TextStrokeTransparency = 0.6
creditsLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
creditsLabel.Text = "CREDITS: DeathZ & Korez"
creditsLabel.TextXAlignment = Enum.TextXAlignment.Center
creditsLabel.TextYAlignment = Enum.TextYAlignment.Center
creditsLabel.Parent = mainFrame

local creditsGradient = Instance.new("UIGradient")
creditsGradient.Color = ColorSequence.new{ ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)), ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 0, 0)) }
creditsGradient.Rotation = 0
creditsGradient.Parent = creditsLabel

task.spawn(function() while task.wait(0.06) do creditsGradient.Rotation = (creditsGradient.Rotation + 3) % 360 end end)

local function setToggleVisual(on)
    if on then
        local tween = TweenService:Create(toggleFrame, TweenInfo.new(0.16, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(0, 200, 70)})
        tween:Play()
        local targetPos = UDim2.new(1, -26, 0.5, -10)
        local knobTween = TweenService:Create(knob, TweenInfo.new(0.16, Enum.EasingStyle.Quad), {Position = targetPos})
        knobTween:Play()
    else
        local tween = TweenService:Create(toggleFrame, TweenInfo.new(0.16, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(200, 0, 0)})
        tween:Play()
        local targetPos = UDim2.new(0, 2, 0.5, -10)
        local knobTween = TweenService:Create(knob, TweenInfo.new(0.16, Enum.EasingStyle.Quad), {Position = targetPos})
        knobTween:Play()
    end
end

-- ======================
-- Logic (instant steal, teleports, anti-death)
-- ======================

local buyArgs = {"Laser Cape"}
local buyRemote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy")
pcall(function() buyRemote:InvokeServer(unpack(buyArgs)) end)

task.wait(0.02)
local laserCape = LocalPlayer.Backpack:FindFirstChild("Laser Cape") or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Laser Cape"))
if not laserCape then
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", { Title = "Laser Cape", Text = "U Need Enough Rebirth For That!", Duration = 6 })
    end)
end

-- AlignPosition helper (used during teleports to improve server reconciliation)
local AlignHelper = Instance.new("AlignPosition")
AlignHelper.Name = "KurdHub_AlignPosition"
AlignHelper.MaxForce = math.huge
AlignHelper.Attachment0 = nil
AlignHelper.Attachment1 = nil
AlignHelper.RigidityEnabled = true
AlignHelper.Responsiveness = 200 -- high responsiveness
AlignHelper.Parent = Workspace -- parented to workspace; Attachment0 will be set per-character

local SuperSteal = Instance.new("BoolValue")
SuperSteal.Value = true

local Character
local RagdollEnabled = false

local function protectHumanoid(humanoid)
    if not humanoid then return end
    pcall(function()
        humanoid.MaxHealth = 1e9
        humanoid.Health = humanoid.MaxHealth
    end)
    humanoid.HealthChanged:Connect(function(h)
        if humanoid and humanoid.Parent and h < (humanoid.MaxHealth or 0) then
            pcall(function() humanoid.Health = humanoid.MaxHealth end)
        end
    end)
    humanoid.Died:Connect(function()
        task.wait(0.02)
        if humanoid and humanoid.Parent then
            pcall(function() humanoid.Health = humanoid.MaxHealth end)
        end
    end)
end

local function makePrimaryAttachment(part)
    if not part then return nil end
    local att = part:FindFirstChild("KurdHub_Attachment")
    if not att then
        att = Instance.new("Attachment")
        att.Name = "KurdHub_Attachment"
        att.Position = Vector3.new(0,0,0)
        att.Parent = part
    end
    return att
end

local function newCharacter(char: Model)
    char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")
    task.wait()
    Character = char
    local hum = Character:FindFirstChildOfClass("Humanoid")
    if hum then protectHumanoid(hum) end

    -- ensure an attachment exists on PrimaryPart and wire AlignHelper to it
    if Character.PrimaryPart then
        local att = makePrimaryAttachment(Character.PrimaryPart)
        if att then
            AlignHelper.Attachment0 = att
        end
    end

    RagdollEnabled = false
    Character:FindFirstChildOfClass("Humanoid").StateChanged:Connect(function(_, state)
        if state == Enum.HumanoidStateType.Physics then
            RagdollEnabled = true
        elseif state == Enum.HumanoidStateType.GettingUp then
            RagdollEnabled = false
        end
    end)
end

if LocalPlayer.Character then newCharacter(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(newCharacter)

-- Predefined positions / paths (kept from original)
local closestPositions = {
    Vector3.new(-457, -8, -100), Vector3.new(-457, -8, 7), Vector3.new(-456, -8, 114), Vector3.new(-456, -8, 221), Vector3.new(-363, -8, 221), Vector3.new(-364, -8, 112), Vector3.new(-365, -8, 4), Vector3.new(-364, -8, -103)
}

local floor2Paths = {
    [Vector3.new(-512, 13, 236)] = {Vector3.new(-519, 13, 190), Vector3.new(-466, 13, 186)},
    [Vector3.new(-512, 13, 128)] = {Vector3.new(-518, 13, 84),  Vector3.new(-468, 13, 79)},
    [Vector3.new(-511, 13, 22)]  = {Vector3.new(-519, 13, -24), Vector3.new(-468, 13, -27)},
    [Vector3.new(-511, 13, -84)] = {Vector3.new(-519, 13, -132), Vector3.new(-471, 13, -132)},
    [Vector3.new(-308, 13, -118)] = {Vector3.new(-302, 13, -69),  Vector3.new(-351, 13, -68)},
    [Vector3.new(-308, 13, -10)]  = {Vector3.new(-303, 13, 36),   Vector3.new(-351, 13, 38)},
    [Vector3.new(-308, 13, 96)]   = {Vector3.new(-302, 13, 144),  Vector3.new(-350, 13, 146)},
    [Vector3.new(-309, 13, 204)]  = {Vector3.new(-302, 13, 250),  Vector3.new(-362, 13, 252)}
}

local floor3Paths = {
    [Vector3.new(-303, 30, -101)] = {Vector3.new(-303, 13, -101), Vector3.new(-303, 13, -69), Vector3.new(-356, 13, -69)},
    [Vector3.new(-304, 30, 6)]    = {Vector3.new(-304, 13, 6),    Vector3.new(-302, 13, 36),  Vector3.new(-355, 13, 40)},
    [Vector3.new(-304, 30, 113)]  = {Vector3.new(-304, 13, 113),  Vector3.new(-303, 13, 144), Vector3.new(-350, 13, 146)},
    [Vector3.new(-304, 30, 220)]  = {Vector3.new(-304, 13, 220),  Vector3.new(-301, 13, 251), Vector3.new(-351, 13, 251)},
    [Vector3.new(-516, 13, 220)]  = {Vector3.new(-516, 30, 220),  Vector3.new(-518, 13, 188), Vector3.new(-470, 13, 189)},
    [Vector3.new(-516, 30, 113)]  = {Vector3.new(-516, 13, 113),  Vector3.new(-518, 13, 83),  Vector3.new(-470, 13, 82)},
    [Vector3.new(-517, 30, 6)]    = {Vector3.new(-517, 13, 6),    Vector3.new(-518, 13, -24), Vector3.new(-470, 13, -26)},
    [Vector3.new(-516, 30, -101)] = {Vector3.new(-516, 13, -101), Vector3.new(-518, 13, -131), Vector3.new(-467, 13, -133)}
}

-- Robust teleport function with slight slow-down and retries for high ping
-- Modified: will retry the entire teleport up to 2 more times (total 3 attempts) if final placement fails.
local function teleportDynamic(fromPos, toPos, fast, retryCount)
    retryCount = retryCount or 0
    if retryCount > 2 then return end -- don't retry more than 2 extra times

    if fast == nil then fast = true end
    if not Character or not Character.PrimaryPart then return end

    -- small jump attempt to avoid ground collision
    local hum = Character:FindFirstChildOfClass("Humanoid")
    if hum then
        pcall(function()
            hum.JumpPower = 5
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end)
        task.wait(0.01)
    end

    local distance = (toPos - fromPos).Magnitude
    local segments

    -- choose segments (still fast but a bit slower than before)
    if fast then
        segments = math.clamp(math.ceil(distance / 140), 1, 6) -- 1..6 segments
    else
        if distance < 80 then segments = 1
        elseif distance < 250 then segments = 2
        else segments = 3
        end
    end

    -- step delay slightly increased to help with server reconciliation on high ping (tunable)
    local stepDelay = fast and 0.06 or 0.09

    -- ensure attachment and align helper are active during teleport
    if Character.PrimaryPart then
        local att = makePrimaryAttachment(Character.PrimaryPart)
        if att then
            AlignHelper.Attachment0 = att
            AlignHelper.Enabled = true
        end
    end

    for i = 1, segments do
        local alpha = i / segments
        local x = fromPos.X + (toPos.X - fromPos.X) * alpha
        local y = fromPos.Y + (toPos.Y - fromPos.Y) * alpha + 2
        local z = fromPos.Z + (toPos.Z - fromPos.Z) * alpha
        pcall(function()
            Character:SetPrimaryPartCFrame(CFrame.new(x, y, z))
            -- clear velocity so momentum doesn't push us away
            if Character.PrimaryPart and Character.PrimaryPart:IsA("BasePart") then
                Character.PrimaryPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
                Character.PrimaryPart.AssemblyAngularVelocity = Vector3.new(0,0,0)
            end
        end)
        task.wait(stepDelay)
    end

    -- final placement + retry loop (helps when the server corrects us due to ping)
    local finalPos = Vector3.new(toPos.X, toPos.Y + 2, toPos.Z)
    local attempts = 0
    local maxAttempts = 4
    while attempts < maxAttempts do
        attempts = attempts + 1
        pcall(function()
            Character:SetPrimaryPartCFrame(CFrame.new(finalPos))
            if Character.PrimaryPart and Character.PrimaryPart:IsA("BasePart") then
                Character.PrimaryPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
                Character.PrimaryPart.AssemblyAngularVelocity = Vector3.new(0,0,0)
            end
        end)
        task.wait(stepDelay + 0.02)
        if not Character or not Character.PrimaryPart then break end
        local cur = Character.PrimaryPart.Position
        if (Vector3.new(cur.X, toPos.Y, cur.Z) - Vector3.new(toPos.X, toPos.Y, toPos.Z)).Magnitude <= 3 then
            break
        end
    end

    -- check final success
    local success = false
    if Character and Character.PrimaryPart then
        local cur = Character.PrimaryPart.Position
        if (Vector3.new(cur.X, toPos.Y, cur.Z) - Vector3.new(toPos.X, toPos.Y, toPos.Z)).Magnitude <= 3 then
            success = true
        end
    end

    -- disable align helper after teleport to return control
    AlignHelper.Enabled = false

    -- if teleport failed and we still have retries left, try again (up to 2 retries)
    if not success and retryCount < 2 then
        task.wait(0.06)
        teleportDynamic(fromPos, toPos, fast, retryCount + 1)
    end
end

-- floor helpers (same logic but using the updated teleportDynamic)
local function getClosestPosition()
    if not Character or not Character.PrimaryPart then return nil end
    local currentPos = Character.PrimaryPart.Position
    local closestDist = math.huge
    local closestPos = currentPos
    for _, pos in pairs(closestPositions) do
        local dist = (Vector3.new(pos.X, 0, pos.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Magnitude
        if dist < closestDist then
            closestDist = dist
            closestPos = pos
        end
    end
    return closestPos
end

local function teleportFloor1(hitbox)
    if not Character or not Character.PrimaryPart then return end
    local startPos = Character.PrimaryPart.Position
    local targetPos = hitbox.Position
    local firstClosest = getClosestPosition()
    teleportDynamic(startPos, firstClosest, true)

    -- calculate next best waypoint
    local nextClosest = firstClosest
    local minDist = math.huge
    local plotDist = (Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(Character.PrimaryPart.Position.X, 0, Character.PrimaryPart.Position.Z)).Magnitude
    for _, pos in pairs(closestPositions) do
        local dist = (Vector3.new(pos.X, 0, pos.Z) - Vector3.new(targetPos.X, 0, targetPos.Z)).Magnitude
        if dist < minDist and pos ~= firstClosest then
            minDist = dist
            nextClosest = pos
        end
    end
    if plotDist < minDist then nextClosest = targetPos end
    teleportDynamic(Character.PrimaryPart.Position, nextClosest, true)

    local behindDir = -hitbox.CFrame.LookVector
    local behindPos = targetPos + behindDir * 18
    behindPos = Vector3.new(behindPos.X, targetPos.Y + 2, behindPos.Z)
    teleportDynamic(Character.PrimaryPart.Position, behindPos, true)
    pcall(function()
        Character:SetPrimaryPartCFrame(CFrame.new(behindPos.X, targetPos.Y, behindPos.Z))
    end)
end

local function teleportFloor2(hitbox)
    if not Character or not Character.PrimaryPart then return end
    local startPos = Character.PrimaryPart.Position
    local targetPos = hitbox.Position
    local firstKey = nil
    local minDist = math.huge
    for key, _ in pairs(floor2Paths) do
        local d = (Vector3.new(key.X, key.Y, key.Z) - startPos).Magnitude
        if d < minDist then
            minDist = d
            firstKey = key
        end
    end
    if firstKey then
        teleportDynamic(startPos, firstKey, true)
        task.wait(0.03)
        for _, wp in ipairs(floor2Paths[firstKey]) do
            teleportDynamic(Character.PrimaryPart.Position, wp, true)
            task.wait(0.03)
        end
    end
    local behindDir = -hitbox.CFrame.LookVector
    local behindPos = targetPos + behindDir * 18
    behindPos = Vector3.new(behindPos.X, targetPos.Y + 2, behindPos.Z)
    teleportDynamic(Character.PrimaryPart.Position, behindPos, true)
    pcall(function()
        Character:SetPrimaryPartCFrame(CFrame.new(behindPos.X, targetPos.Y, behindPos.Z))
    end)
end

local function teleportFloor3(hitbox)
    if not Character or not Character.PrimaryPart then return end
    local startPos = Character.PrimaryPart.Position
    local firstKey = nil
    local minDist = math.huge

    for key, _ in pairs(floor3Paths) do
        local dxz = (Vector3.new(key.X, 0, key.Z) - Vector3.new(startPos.X, 0, startPos.Z)).Magnitude
        local dy = math.abs(key.Y - startPos.Y)
        local score = dxz + (dy * 0.6)
        if score < minDist then
            minDist = score
            firstKey = key
        end
    end

    local isFast = true
    if firstKey then
        teleportDynamic(startPos, firstKey, isFast)
        task.wait(0.03)
        for _, wp in ipairs(floor3Paths[firstKey]) do
            teleportDynamic(Character.PrimaryPart.Position, wp, isFast)
            task.wait(0.03)
        end
    end

    local targetPos = hitbox.Position
    local behindDir = -hitbox.CFrame.LookVector
    local behindPos = targetPos + behindDir * 18
    behindPos = Vector3.new(behindPos.X, targetPos.Y + 2, behindPos.Z)
    teleportDynamic(Character.PrimaryPart.Position, behindPos, isFast)
    pcall(function()
        Character:SetPrimaryPartCFrame(CFrame.new(behindPos.X, targetPos.Y, behindPos.Z))
    end)
end

local function TeleportToHitbox(hitbox)
    if not Character or not Character.PrimaryPart then return end
    local y = Character.PrimaryPart.Position.Y
    if y >= 8 and y <= 15 then
        teleportFloor2(hitbox)
    elseif y > 15 then
        teleportFloor3(hitbox)
    else
        teleportFloor1(hitbox)
    end
end

-- optimized steal (keeps original intent but uses robust teleports)
local function onSteal()
    if not SuperSteal.Value then return end
    if not LocalPlayer.Character then return end

    local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        local tool = LocalPlayer.Backpack:FindFirstChild("Laser Cape") or LocalPlayer.Character:FindFirstChild("Laser Cape")
        if tool then
            hum:EquipTool(tool)
        else
            local args = {"Laser Cape"}
            pcall(function()
                ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy"):InvokeServer(unpack(args))
            end)
            tool = LocalPlayer.Backpack:FindFirstChild("Laser Cape")
            if tool then hum:EquipTool(tool) end
        end
    end

    local remote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RE/UseItem")
    if LocalPlayer.Character then
        pcall(function()
            local args = {Vector3.new(-309.9097, -4.7108, 221.585), LocalPlayer.Character:WaitForChild("LeftUpperArm")}
            remote:FireServer(unpack(args))
        end)
    end

    local Hitbox = Workspace:WaitForChild("SpawnLocation")
    for _, v in pairs(Workspace.Plots:GetChildren()) do
        if v:FindFirstChild("PlotSign") and v.PlotSign.YourBase and v.PlotSign.YourBase.Enabled then
            Hitbox = v:FindFirstChild("DeliveryHitbox") or Hitbox
            break
        end
    end

    TeleportToHitbox(Hitbox)
end

-- Prompt listener
local promptConnection = nil
local isActive = false
local isBusy = false

promptConnection = ProximityPromptService.PromptTriggered:Connect(function(prompt, plr)
    if not isActive then return end
    if isBusy then return end
    if plr ~= LocalPlayer then return end
    if not prompt or prompt.ActionText ~= "Steal" then return end

    isBusy = true
    task.spawn(function()
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            local tool = LocalPlayer.Backpack:FindFirstChild("Laser Cape") or LocalPlayer.Character:FindFirstChild("Laser Cape")
            if tool then
                hum:EquipTool(tool)
            else
                local args = {"Laser Cape"}
                pcall(function()
                    ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy"):InvokeServer(unpack(args))
                end)
                tool = LocalPlayer.Backpack:FindFirstChild("Laser Cape")
                if tool then hum:EquipTool(tool) end
            end
        end

        local remote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RE/UseItem")
        if LocalPlayer.Character then
            pcall(function()
                local args = {Vector3.new(-309.9097, -4.7108, 221.585), LocalPlayer.Character:WaitForChild("LeftUpperArm")}
                remote:FireServer(unpack(args))
            end)
        end

        pcall(onSteal)
        isBusy = false
    end)
end)

-- Expose functions for console
_G.KurdHub_OnSteal = onSteal
_G.KurdHub_Enable = function() isActive = true setToggleVisual(true) end
_G.KurdHub_Disable = function() isActive = false setToggleVisual(false) end

-- Hook toggle clicks (notifications removed)
toggleFrame.MouseButton1Click:Connect(function()
    isActive = not isActive
    setToggleVisual(isActive)
end)

setToggleVisual(isActive)

-- End of script (prints removed)
