-- Merged Taser script (height set to 2.8)
if not game:IsLoaded() then game.Loaded:Wait() end

-- Services & locals
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local TOOL_NAME = "Taser Gun"
local PROMPT_HOLD_TIME = 1.50
local FORWARD_DISTANCE = 34 -- forward distance in studs (configurable)

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local hrp = Character:WaitForChild("HumanoidRootPart")
local Backpack = LocalPlayer:WaitForChild("Backpack")

-- UI toggle (draggable)
local stopMovement = false
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "KorezTaserUI"
screenGui.ResetOnSpawn = false
pcall(function() if syn and syn.protect_gui then syn.protect_gui(screenGui) end end)
screenGui.Parent = game.CoreGui

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 180, 0, 50)
toggleButton.Position = UDim2.new(0, 10, 0.5, -25)
toggleButton.Text = ""
toggleButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
toggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 18
toggleButton.Parent = screenGui
toggleButton.Active = true

local dragFrame = Instance.new("Frame")
dragFrame.Name = "DragFrame"
dragFrame.Size = toggleButton.Size
dragFrame.BackgroundTransparency = 1
dragFrame.Parent = screenGui
dragFrame.Position = toggleButton.Position

local function updateToggleUI()
    if stopMovement then
        toggleButton.Text = "Script Off!"
        toggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    else
        toggleButton.Text = "Script working!"
        toggleButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        toggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    end
end

-- Persist toggled-on state across death using a Player attribute
if LocalPlayer:GetAttribute("KorezGrapple_On") ~= nil then
    local attr = LocalPlayer:GetAttribute("KorezGrapple_On") -- attr==true means script should be ON -> stopMovement false
    stopMovement = not attr
else
    LocalPlayer:SetAttribute("KorezGrapple_On", not stopMovement)
end

updateToggleUI()

toggleButton.MouseButton1Click:Connect(function()
    stopMovement = not stopMovement
    LocalPlayer:SetAttribute("KorezGrapple_On", not stopMovement)
    updateToggleUI()
end)

-- make the button draggable (works in CoreGui)
do
    local dragging = false
    local dragInput, dragStart, startPos
    local function update(input)
        local delta = input.Position - dragStart
        local newPos = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
        toggleButton.Position = newPos
        dragFrame.Position = newPos
    end

    toggleButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = toggleButton.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    toggleButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            pcall(update, input)
        end
    end)
end

-- ===================================================================
-- Network-lag adaptation (estimate proxy and use to scale waits/tolerances)
-- ===================================================================
local networkLag = 0.17 -- initial guess in seconds (0.18 ~ 180ms)

local function sampleNetworkLag(newSample)
    if not newSample or type(newSample) ~= "number" then return end
    networkLag = (networkLag * 5 + newSample) / 6
    networkLag = math.clamp(networkLag, 0.03, 2)
end

local function netWait(base)
    local extra = math.clamp(networkLag * 0.5, 0, base * 2)
    task.wait(math.max(base, base + extra))
end

-- ===================================================================
-- Taser Module (keeps tool equipped & fires remote while movement runs)
-- adaptive to lag
-- ===================================================================
local TaserModule = (function()
    local player = Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local argsValues = { 0.3232789675394694, 0.21900957425435383, 0.1810441811879476, 0.22647995948791505, 0.4191658973693847, 0.6830041249593098, 0.43952007293701173, 0.5122152328491211, 0.7234668731689453 }
    local currentArgIndex = 1
    local active = false
    local taskHandle = nil
    local forceEquipConnection = nil
    local previouslyEquippedTool = nil
    local debounce = false

    local function getCharacter()
        local ch = player.Character or player.CharacterAdded:Wait()
        local humanoid = ch:FindFirstChildOfClass("Humanoid") or ch:WaitForChild("Humanoid")
        return ch, humanoid
    end

    local function findTool()
        local ch = player.Character
        for _, container in pairs({backpack, ch}) do
            if container then
                for _, item in pairs(container:GetChildren()) do
                    if item:IsA("Tool") and item.Name == TOOL_NAME then return item end
                end
            end
        end
        return nil
    end

    local function buyToolWithRetries(maxAttempts)
        maxAttempts = maxAttempts or 3
        local attempt = 1
        local backoff = 0.12 + networkLag
        local packages = ReplicatedStorage:FindFirstChild("Packages")
        while attempt <= maxAttempts and not findTool() and not stopMovement do
            local startT = tick()
            pcall(function()
                if packages then
                    local net = packages:FindFirstChild("Net")
                    if net and net:FindFirstChild("RF/CoinsShopService/RequestBuy") then
                        pcall(function() net["RF/CoinsShopService/RequestBuy"]:InvokeServer(TOOL_NAME) end)
                    end
                end
            end)
            local waited = 0
            local timeout = 1.5 + (networkLag * 3)
            while waited < timeout and not findTool() and not stopMovement do
                task.wait(0.1)
                waited = waited + 0.1
            end
            local elapsed = tick() - startT
            if findTool() then sampleNetworkLag(elapsed) break end
            attempt = attempt + 1
            task.wait(backoff * attempt)
        end
    end

    local function waitForToolEquipped(tool, timeout)
        timeout = timeout or (1.5 + networkLag * 2)
        local start = tick()
        while tick() - start < timeout do
            if Character and Character:FindFirstChild(tool.Name) then
                sampleNetworkLag(tick() - start)
                return true
            end
            task.wait(0.05)
        end
        return false
    end

    local function equipTool(tool)
        local character, humanoid = getCharacter()
        if not tool or not tool:IsDescendantOf(backpack) then return end
        if humanoid.Health <= 0 then return end

        local attempts = 0
        local maxAttempts = 4
        while attempts < maxAttempts and not stopMovement do
            attempts = attempts + 1
            local startT = tick()
            pcall(function() humanoid:EquipTool(tool) end)
            local ok = waitForToolEquipped(tool, 1.5 + networkLag * 2)
            local elapsed = tick() - startT
            if ok then
                sampleNetworkLag(elapsed)
                break
            else
                task.wait(0.08 + networkLag * 0.6)
            end
        end

        if forceEquipConnection then
            forceEquipConnection:Disconnect()
            forceEquipConnection = nil
        end

        forceEquipConnection = RunService.Heartbeat:Connect(function()
            if not active then return end
            if not character:FindFirstChild(tool.Name) then
                pcall(function() humanoid:EquipTool(tool) end)
            end
        end)
    end

    local function attemptSelfFire(useRemote, arg)
        if not useRemote then return end
        local ch, hum = getCharacter()
        local hrp_local = (ch and ch:FindFirstChild("HumanoidRootPart")) or nil

        local attempts = {
            function() pcall(function() useRemote:FireServer(ch) end) end,
            function() if hrp_local then pcall(function() useRemote:FireServer(hrp_local) end) end end,
            function() pcall(function() useRemote:FireServer(player) end) end,
            function() pcall(function() useRemote:FireServer(player.UserId) end) end,
            function() pcall(function() useRemote:FireServer(arg) end) end,
        }
        for _,fn in ipairs(attempts) do
            pcall(fn)
        end
    end

    local function activateTaser()
        local useRemote
        pcall(function()
            local packages = ReplicatedStorage:FindFirstChild("Packages")
            if packages then
                local net = packages:FindFirstChild("Net")
                if net then useRemote = net:FindFirstChild("RE/UseItem") end
            end
        end)

        if taskHandle then taskHandle = nil end
        if not useRemote then return end

        taskHandle = task.spawn(function()
            while active do
                local tool = findTool()
                local character, humanoid = getCharacter()
                if tool and humanoid and tool.Parent == backpack then
                    pcall(function() humanoid:EquipTool(tool) end)
                    task.wait(0.05 + math.clamp(networkLag * 0.4, 0, 0.6))
                end

                local arg = argsValues[currentArgIndex]
                currentArgIndex = (currentArgIndex % #argsValues) + 1

                pcall(function()
                    attemptSelfFire(useRemote, arg)
                end)

                task.wait(2.7)
            end
        end)
    end

    local function enableLoop()
        if debounce then return end
        debounce = true
        pcall(function()
            local character, humanoid = getCharacter()
            if not character or not humanoid then return end
            active = true
            local tool = findTool()
            if not tool then
                buyToolWithRetries(4)
                tool = findTool()
                if not tool then
                    warn("Failed to acquire Taser Gun.")
                    active = false
                    return
                end
            end

            for _, t in pairs(character:GetChildren()) do
                if t:IsA("Tool") and t ~= tool then
                    previouslyEquippedTool = t
                    break
                end
            end

            equipTool(tool)
            activateTaser()
        end)
        debounce = false
    end

    local function unequipCurrentTool()
        local character = player.Character
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then tool.Parent = backpack end
        end
    end

    local function disableLoop()
        if debounce then return end
        debounce = true
        pcall(function()
            active = false
            if taskHandle then taskHandle = nil end

            if forceEquipConnection then
                forceEquipConnection:Disconnect()
                forceEquipConnection = nil
            end

            local character, humanoid = getCharacter()
            local tool = findTool()
            if tool and tool.Parent == character then
                tool.Parent = backpack
            end

            if previouslyEquippedTool and previouslyEquippedTool:IsDescendantOf(backpack) then
                pcall(function() humanoid:EquipTool(previouslyEquippedTool) end)
            end

            previouslyEquippedTool = nil
        end)
        debounce = false
    end

    local function isActive() return active end

    return { Enable = enableLoop, Disable = disableLoop, Unequip = unequipCurrentTool, FindTool = findTool, IsActive = isActive }

end)()

-- ===================================================================
-- Movement / delivery logic (avoid freezing at nearby hitboxes)
-- ===================================================================

local function FindNearestDeliveryHitbox()
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return nil end
    local closest, closestDist = nil, math.huge
    for _, plot in pairs(plots:GetChildren()) do
        local hitbox = plot:FindFirstChild("DeliveryHitbox")
        if hitbox and hitbox:IsA("BasePart") then
            local dist = (hitbox.Position - hrp.Position).Magnitude
            if dist < closestDist then closestDist = dist closest = hitbox end
        end
    end
    return closest
end

local function findMyDeliveryHitbox()
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in pairs(plots:GetChildren()) do
        for _, desc in ipairs(plot:GetDescendants()) do
            if desc:IsA("TextLabel") and (desc.Text:find(LocalPlayer.Name) or desc.Text:find(LocalPlayer.DisplayName)) then
                for _, child in ipairs(plot:GetDescendants()) do
                    if child.Name == "DeliveryHitbox" and child:IsA("BasePart") then return child end
                end
            end
        end
    end
    return nil
end

local function setupFlight()
    if hrp:FindFirstChild("FlightAttachment") then hrp.FlightAttachment:Destroy() end
    if hrp:FindFirstChild("FlightVelocity") then hrp.FlightVelocity:Destroy() end
    local attachment = Instance.new("Attachment")
    attachment.Name = "FlightAttachment"
    attachment.Parent = hrp
    local lv = Instance.new("LinearVelocity")
    lv.Attachment0 = attachment
    lv.RelativeTo = Enum.ActuatorRelativeTo.World
    lv.MaxForce = math.huge
    lv.Name = "FlightVelocity"
    lv.Parent = hrp
    return lv, attachment
end

local function getLaserCenter(model)
    if not model then return nil end
    if model:IsA("BasePart") then return model.Position end
    if not model:IsA("Model") then return nil end
    local parts = {}
    for _, d in ipairs(model:GetDescendants()) do if d:IsA("BasePart") then table.insert(parts, d) end end
    if #parts == 0 then return nil end
    local sum = Vector3.new(0, 0, 0)
    for _, p in ipairs(parts) do sum = sum + p.Position end
    return sum / #parts
end

-- speed variables
local movementSpeed = 175
local deliverySpeed = 304
local isMoving = false
local currentStage = "none"
local currentTarget = nil

local function isPositionClear(pos, radius)
    local okRadius = math.max(1, radius)
    local min = pos - Vector3.new(okRadius, 2, okRadius)
    local max = pos + Vector3.new(okRadius, 4, okRadius)
    local region = Region3.new(min, max)
    pcall(function() region = region:ExpandToGrid(4) end)
    local ignoreList = {}
    if Character then table.insert(ignoreList, Character) end
    local parts = Workspace:FindPartsInRegion3WithIgnoreList(region, ignoreList, 32)
    for _, p in ipairs(parts) do
        if p and p.CanCollide then return false end
    end
    return true
end

-- NEW: score candidate directions by sampling a few distances and counting clear checks
local function scoreDirection(origin, dirUnit, samples, radii, clearanceRadius)
    local score = 0
    local lastClearPos = nil
    for _, dist in ipairs(radii) do
        local candidate = origin + Vector3.new(dirUnit.X * dist, 0, dirUnit.Z * dist) + Vector3.new(0, 3, 0)
        if isPositionClear(candidate, clearanceRadius) then score = score + 1 lastClearPos = candidate end
    end
    return score, lastClearPos
end

-- NEW: choose the best empty direction around the player relative to a target
local function chooseBestEmptyDirection(targetPos)
    local origin = hrp.Position
    local look = hrp.CFrame.LookVector
    local right = hrp.CFrame.RightVector
    local directions = {
        {name = "forward", vec = Vector3.new(look.X, 0, look.Z)},
        {name = "back", vec = Vector3.new(-look.X, 0, -look.Z)},
        {name = "right", vec = Vector3.new(right.X, 0, right.Z)},
        {name = "left", vec = Vector3.new(-right.X, 0, -right.Z)},
        {name = "fwd-right", vec = (look + right).Unit},
        {name = "fwd-left", vec = (look - right).Unit},
        {name = "back-right", vec = (-look + right).Unit},
        {name = "back-left", vec = (-look - right).Unit},
    }
    local radii = {4, 8, 12}
    local clearanceRadius = 2
    local bestScore = -1
    local bestPos = nil
    local bestDirName = nil

    for _, d in ipairs(directions) do
        local vec = d.vec
        if vec.Magnitude == 0 then vec = Vector3.new(0, 0, 0.0001) end
        local unit = vec.Unit
        local score, lastClear = scoreDirection(origin, unit, 3, radii, clearanceRadius)
        local toTarget = (targetPos - origin)
        local dotPref = (toTarget.Unit:Dot(unit) or 0)
        local adjustedScore = score + math.clamp(dotPref, -0.25, 0.5)
        if adjustedScore > bestScore then
            bestScore = adjustedScore
            bestPos = lastClear
            bestDirName = d.name
        end
    end

    if not bestPos then
        for angle = 0, 315, 45 do
            local rad = math.rad(angle)
            local offset = Vector3.new(math.cos(rad) * 6, 0, math.sin(rad) * 6)
            local cand = origin + offset + Vector3.new(0, 3, 0)
            if isPositionClear(cand, 2) then
                bestPos = cand
                break
            end
        end
    end

    return bestPos, bestDirName

end

local function findNearbyEmptyPosition(targetHitbox)
    if not targetHitbox or not targetHitbox:IsA("BasePart") then return nil end
    local targetPos = targetHitbox.Position
    local radii = {4, 6, 8, 10}
    for _, r in ipairs(radii) do
        for angle = 0, 315, 45 do
            local rad = math.rad(angle)
            local offset = Vector3.new(math.cos(rad) * r, 0, math.sin(rad) * r)
            local candidate = targetPos + offset + Vector3.new(0, 3, 0)
            if isPositionClear(candidate, 2) then
                if (candidate - hrp.Position).Magnitude <= 300 then return candidate end
            end
        end
    end
    return nil
end

-- moveUntilLinear: moves until conditionFunc true, with directionFunc returning desired vector.
local function moveUntilLinear(conditionFunc, directionFunc, callback, groundMove, speedOverride)
    local lv, attachment = setupFlight()
    local speed = speedOverride or movementSpeed
    local conn
    local sidestepActive = false
    local sidestepTarget = nil
    local sidestepTimer = 0

    conn = RunService.Heartbeat:Connect(function()
        if not isMoving or stopMovement then
            if lv then lv.VectorVelocity = Vector3.zero lv:Destroy() end
            if attachment then attachment:Destroy() end
            conn:Disconnect()
            return
        end

        if conditionFunc() then
            if lv then lv.VectorVelocity = Vector3.zero lv:Destroy() end
            if attachment then attachment:Destroy() end
            conn:Disconnect()
            if callback then callback() end
        else
            local dir = directionFunc()
            if dir and dir.Magnitude > 0 then
                local checkDist = math.max(4, math.min(dir.Magnitude, 20))
                local rayParams = RaycastParams.new()
                rayParams.FilterDescendantsInstances = {Character}
                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                local ok, ray = pcall(function()
                    return Workspace:Raycast(hrp.Position, Vector3.new(dir.X, 0, dir.Z).Unit * checkDist, rayParams)
                end)

                local blocked = false
                if ok and ray and ray.Instance and ray.Instance.CanCollide then
                    blocked = true
                end

                if blocked and not sidestepActive then
                    local targetPos = (currentTarget and (type(currentTarget) == "Instance" and currentTarget:IsA("BasePart") and currentTarget.Position))
                                    or (hrp.Position + dir)
                    local bestPos, dirName = chooseBestEmptyDirection(targetPos or hrp.Position + dir)
                    if bestPos then
                        sidestepActive = true
                        sidestepTarget = bestPos
                        sidestepTimer = tick()
                    else
                        local fallback = findNearbyEmptyPosition(currentTarget or hrp)
                        if fallback then
                            sidestepActive = true
                            sidestepTarget = fallback
                            sidestepTimer = tick()
                        end
                    end
                end

                if sidestepActive and sidestepTarget and (tick() - sidestepTimer) < (1.2 + networkLag) then
                    local toSide = sidestepTarget - hrp.Position
                    if groundMove then toSide = Vector3.new(toSide.X, 0, toSide.Z) end
                    if toSide.Magnitude > 0.5 then
                        local unit = toSide.Unit
                        lv.VectorVelocity = Vector3.new(unit.X * speed, 0, unit.Z * speed)
                    else
                        sidestepActive = false
                        sidestepTarget = nil
                    end
                    return
                else
                    sidestepActive = false
                    sidestepTarget = nil
                end

                if groundMove then
                    dir = Vector3.new(dir.X, 0, dir.Z)
                    if dir.Magnitude > 0 then
                        local unit = dir.Unit
                        lv.VectorVelocity = Vector3.new(unit.X * speed, 0, unit.Z * speed)
                    else
                        lv.VectorVelocity = Vector3.zero
                    end
                else
                    dir = dir.Unit
                    lv.VectorVelocity = Vector3.new(dir.X * speed, dir.Y * speed, dir.Z * speed)
                end
            else
                lv.VectorVelocity = Vector3.zero
            end
        end
    end)

end

local moveToDelivery -- forward decl
local function computeAutoStopThreshold(hitbox)
    local hrpRadius = math.max(hrp.Size.X, hrp.Size.Z) * 0.5
    local targetRadius = 0.5
    if hitbox and hitbox:IsA("BasePart") then targetRadius = math.max(hitbox.Size.X, hitbox.Size.Z) * 0.5 end
    local buffer = 0.5 + (networkLag * 2)
    local threshold = hrpRadius + targetRadius + buffer
    if threshold < 0.5 then threshold = 0.5 end
    return threshold
end

-- NEW: personal safe threshold (adds a small extra margin to ensure we never come within 1 stud)
local function computePersonalSafeThreshold(hitbox)
    local base = computeAutoStopThreshold(hitbox)
    local extraMargin = 1.2 -- ensures at least ~1 stud+ safe gap in practice (adjust if you want more)
    return base + extraMargin
end

-- moveToDelivery: stop BEFORE touching personal delivery hitbox and perform freeze for 2.1s (no jump)
moveToDelivery = function(forceRetry)
    if stopMovement then return end
    currentStage = "moving_to_delivery"
    local targetHitbox = findMyDeliveryHitbox()
    if not targetHitbox then task.wait(0.2 + networkLag) if isMoving and not stopMovement then moveToDelivery(true) end return end

    local lv, attachment = setupFlight()
    local speed = deliverySpeed
    local reached = false
    local startTime = tick()
    local blockedTries = 0
    local targetPos = targetHitbox.Position - Vector3.new(0, 2.8, 0)

    local isPersonalHitbox = true
    -- STOP before the personal hitbox using a strict safe threshold (guarantees we won't get within ~1 stud)
    local jumpThreshold = 7  -- <-- freeze when within 7 studs of the personal targetPos

    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not isMoving or stopMovement then
            if lv then lv.VectorVelocity = Vector3.zero lv:Destroy() end
            if attachment then attachment:Destroy() end
            connection:Disconnect()
            return
        end

        if not targetHitbox or not targetHitbox:IsDescendantOf(Workspace) then
            targetHitbox = findMyDeliveryHitbox()
            if not targetHitbox then
                if lv then lv.VectorVelocity = Vector3.zero lv:Destroy() end
                connection:Disconnect()
                task.wait(0.5 + networkLag)
                if isMoving and not stopMovement then moveToDelivery(true) end
                return
            else
                targetPos = targetHitbox.Position - Vector3.new(0, 2.8, 0)
            end
        end

        targetPos = targetHitbox.Position - Vector3.new(0, 2.8, 0)

        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {Character}
        rayParams.FilterType = Enum.RaycastFilterType.Exclude
        local dirVec = targetPos - hrp.Position
        local ray = Workspace:Raycast(hrp.Position, dirVec, rayParams)
        if ray and ray.Instance then
            local hitInst = ray.Instance
            if hitInst ~= targetHitbox and not hitInst:IsDescendantOf(targetHitbox.Parent) then
                blockedTries = blockedTries + 1

                local nearby = nil
                nearby = findNearbyEmptyPosition(targetHitbox)
                if not nearby then
                    local bestPos, dirName = chooseBestEmptyDirection(targetPos)
                    if bestPos then nearby = bestPos end
                end

                if nearby then
                    targetPos = nearby
                else
                    if blockedTries > 4 then
                        blockedTries = 0
                    end
                end
            else
                blockedTries = 0
            end
        end

        local direction = (targetPos - hrp.Position)
        local distance = direction.Magnitude

        -- NEW: perform freeze (2.1s) BEFORE personal hitbox and then stop moving (no jump)
        if isPersonalHitbox and distance <= jumpThreshold then
            -- cleanup flight/attachment before freezing
            if lv then pcall(function() lv.VectorVelocity = Vector3.zero end) pcall(function() lv:Destroy() end) end
            if attachment then pcall(function() attachment:Destroy() end) end
            connection:Disconnect()

            -- mark stopped (we won't continue movement loops)
            isMoving = false
            currentStage = "frozen_before_personal_hitbox"

            -- don't freeze if we're already essentially on the hitbox (avoid freezing when standing on it)
            local distToHitbox = (hrp.Position - targetHitbox.Position).Magnitude
            if distToHitbox <= 1.2 then
                -- close enough: just exit without freeze
                currentStage = "none"
                if lv then pcall(function() lv:Destroy() end) end
                return
            end

            -- store previous movement / humanoid states to restore
            local prevAnchored, prevPlatformStand, prevWalkSpeed, prevJumpPower, prevAutoRotate
            pcall(function()
                prevAnchored = hrp.Anchored
            end)
            pcall(function()
                prevPlatformStand = (Humanoid and Humanoid.PlatformStand) or false
                prevWalkSpeed = (Humanoid and Humanoid.WalkSpeed) or 16
                prevJumpPower = (Humanoid and Humanoid.JumpPower) or 50
                prevAutoRotate = (Humanoid and Humanoid.AutoRotate) or true
            end)

            -- apply a hard freeze (no movement while frozen)
            pcall(function()
                if Humanoid then
                    Humanoid.PlatformStand = true
                    Humanoid.WalkSpeed = 0
                    Humanoid.JumpPower = 0
                    Humanoid.AutoRotate = false
                end
            end)
            pcall(function()
                hrp.Velocity = Vector3.new(0,0,0)
                hrp.AssemblyLinearVelocity = Vector3.new(0,0,0)
                hrp.Anchored = true
            end)

            -- freeze duration: 2.1 seconds (respecting small network-lag factor isn't necessary but kept minimal)
            task.wait(2.1)

            -- restore previous states
            pcall(function() hrp.Anchored = prevAnchored end)
            pcall(function()
                if Humanoid then
                    Humanoid.PlatformStand = prevPlatformStand
                    -- ensure reasonable fallback values
                    if prevWalkSpeed and prevWalkSpeed > 0 then Humanoid.WalkSpeed = prevWalkSpeed else Humanoid.WalkSpeed = 16 end
                    if prevJumpPower and prevJumpPower > 0 then Humanoid.JumpPower = prevJumpPower else Humanoid.JumpPower = 50 end
                    Humanoid.AutoRotate = prevAutoRotate
                end
            end)

            -- finalize: leave script not moving; disable taser & cleanup gravity
            currentStage = "none"
            pcall(function() TaserModule.Disable() end)
            pcall(function() TaserModule.Unequip() end)
            pcall(function() disableLowGravity() end)

            return
        end

        -- arrival condition for non-personal nearby hitboxes
        if distance <= 5 + math.clamp(networkLag * 2, 0, 6) then
            if lv then lv.VectorVelocity = Vector3.zero lv:Destroy() end
            if attachment then attachment:Destroy() end
            connection:Disconnect()
            reached = true
            currentStage = "at_nearby_hitbox"
            return
        end

        if tick() - startTime > 90 + (networkLag * 60) then
            if lv then lv.VectorVelocity = Vector3.zero lv:Destroy() end
            connection:Disconnect()
            if isMoving and not stopMovement then moveToDelivery(true) end
            return
        end

        local unitDir = direction.Unit
        lv.VectorVelocity = Vector3.new(unitDir.X * speed, unitDir.Y * speed, unitDir.Z * speed)
    end)

    while not reached and not stopMovement and isMoving do task.wait(0.02) end

end

local function moveToTarget(target, finalCallback, groundMove)
    if stopMovement then return end
    currentStage = "moving_to_target"
    currentTarget = target
    local pos = getLaserCenter(target)
    if not pos then isMoving = false currentStage = "none" if finalCallback then finalCallback() end return end
    local isDeliveryHitbox = false
    if typeof(target) == "Instance" and target:IsA("BasePart") and target.Name == "DeliveryHitbox" then isDeliveryHitbox = true end

    if isDeliveryHitbox then
        pos = Vector3.new(target.Position.X, target.Position.Y - 2.8, target.Position.Z)
    else
        if groundMove and hrp then pos = Vector3.new(pos.X, hrp.Position.Y - 2.8, pos.Z) end
    end

    local tolerance = 0.5 + (networkLag * 1.2)

    moveUntilLinear(
        function()
            local charPos = hrp.Position
            local dx = math.abs(charPos.X - pos.X)
            local dz = math.abs(charPos.Z - pos.Z)
            local reached = dx < tolerance and dz < tolerance
            if reached then currentStage = "at_target" end
            return reached
        end,
        function() return pos - hrp.Position end,
        function() if finalCallback then finalCallback() else moveToDelivery() end end,
        (isDeliveryHitbox and false) or groundMove,
        (isDeliveryHitbox and deliverySpeed) or nil
    )
end

-- ========== LOW GRAVITY WHILE MOVING (per-player) ==========
local normalLowGravityScale = 0.35
local prolongedLowGravityScale = 0.12
local prolongedThreshold = 1
local lowGravityScale = normalLowGravityScale
local lowGravityForce = nil
local lowGravityConn = nil
local movementStartTime = nil

function enableLowGravity()
    if not hrp or hrp.Parent == nil then return end
    if lowGravityForce then return end
    local ok, mass = pcall(function() return hrp:GetMass() end)
    mass = ok and mass or 1
    local bf = Instance.new("BodyForce")
    bf.Name = "LowGravityForce"
    bf.Force = Vector3.new(0, Workspace.Gravity * mass * (1 - lowGravityScale), 0)
    bf.Parent = hrp
    lowGravityForce = bf
    if lowGravityConn then lowGravityConn:Disconnect() end
    lowGravityConn = RunService.Heartbeat:Connect(function()
        if not lowGravityForce or not hrp or hrp.Parent == nil then disableLowGravity() return end
        local ok2, mass2 = pcall(function() return hrp:GetMass() end)
        mass2 = ok2 and mass2 or mass
        if lowGravityForce then lowGravityForce.Force = Vector3.new(0, Workspace.Gravity * mass2 * (1 - lowGravityScale), 0) end
    end)
end

function disableLowGravity()
    if lowGravityConn then pcall(function() lowGravityConn:Disconnect() end) end
    lowGravityConn = nil
    if lowGravityForce then pcall(function() lowGravityForce:Destroy() end) end
    lowGravityForce = nil
end

RunService.Heartbeat:Connect(function()
    if isMoving and not stopMovement then
        if not movementStartTime then movementStartTime = tick() end
        local elapsed = tick() - movementStartTime
        if elapsed >= prolongedThreshold then lowGravityScale = prolongedLowGravityScale else lowGravityScale = normalLowGravityScale end
        if not lowGravityForce then pcall(enableLowGravity) else pcall(function() local ok2, mass2 = pcall(function() return hrp:GetMass() end) mass2 = ok2 and mass2 or 1 if lowGravityForce then lowGravityForce.Force = Vector3.new(0, Workspace.Gravity * mass2 * (1 - lowGravityScale), 0) end end) end
    else
        movementStartTime = nil
        if lowGravityForce then pcall(disableLowGravity) end
    end
end)

-- Ensure cleanup on character respawn
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    hrp = newCharacter:WaitForChild("HumanoidRootPart")
    Humanoid = newCharacter:WaitForChild("Humanoid")

    currentStage = "none"
    isMoving = false

    pcall(function() disableLowGravity() end)

    if hrp then pcall(function() hrp.Anchored = false end) end

    pcall(function() TaserModule.Disable() end)

    local shouldBeOn = LocalPlayer:GetAttribute("KorezGrapple_On")
    if shouldBeOn == nil then shouldBeOn = not stopMovement end
    stopMovement = not shouldBeOn
    updateToggleUI()
end)

LocalPlayer.CharacterRemoving:Connect(function(oldCharacter)
    isMoving = false
    currentStage = "none"
    pcall(function() TaserModule.Disable() end)
    pcall(function() disableLowGravity() end)
end)

-- Floor detection helpers (namespaced)
local function FloorDetect_isSizeClose(partSize, targetSize, tolerance)
    return math.abs(partSize.X - targetSize.X) <= tolerance and math.abs(partSize.Y - targetSize.Y) <= tolerance and math.abs(partSize.Z - targetSize.Z) <= tolerance
end

local function FloorDetect_getLaserCenter(model)
    if not model:IsA("Model") then return nil end
    local primary = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if not primary then return nil end
    return primary.Position
end

local function FloorDetect_getTargetForFloor(level, fromThirdFloor)
    local closestTarget, closestDistance = nil, math.huge
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in ipairs(plots:GetChildren()) do
        if level == 1 then
            return nil
        elseif level == 2 then
            if not fromThirdFloor then
                local modelFolder = plot:FindFirstChild("Model")
                local foundInitialTarget = false
                if modelFolder then
                    for _, obj in ipairs(modelFolder:GetChildren()) do
                        if obj:IsA("BasePart") and FloorDetect_isSizeClose(obj.Size, Vector3.new(5,1,1), 0.01) then
                            local dist = (obj.Position - hrp.Position).Magnitude
                            if dist < 5 then
                                if dist < closestDistance then closestDistance = dist closestTarget = obj foundInitialTarget = true end
                            end
                        end
                    end
                end
                if not foundInitialTarget then
                    local decorations = plot:FindFirstChild("Decorations")
                    if decorations then
                        for _, obj in ipairs(decorations:GetChildren()) do
                            if obj:IsA("BasePart") and FloorDetect_isSizeClose(obj.Size, Vector3.new(45,45,2), 0.01) then
                                local posY = obj.Position.Y
                                if posY >= 8 and posY <= 9.1 then
                                    local dist = (obj.Position - hrp.Position).Magnitude
                                    if dist < closestDistance then closestDistance = dist closestTarget = obj end
                                end
                            end
                        end
                    end
                end
            else
                local decorations = plot:FindFirstChild("Decorations")
                if decorations then
                    for _, obj in ipairs(decorations:GetChildren()) do
                        if obj:IsA("BasePart") and FloorDetect_isSizeClose(obj.Size, Vector3.new(17,10,2), 0.01) then
                            local dist = (obj.Position - hrp.Position).Magnitude
                            if dist < closestDistance then closestDistance = dist closestTarget = obj end
                        end
                    end
                end
            end
        elseif level == 3 then
            local laserHitboxFolder = plot:FindFirstChild("LaserHitbox")
            if laserHitboxFolder then
                local thirdFloorPart = laserHitboxFolder:FindFirstChild("ThirdFloor")
                if thirdFloorPart then
                    local dist = (thirdFloorPart.Position - hrp.Position).Magnitude
                    if dist < closestDistance then closestDistance = dist closestTarget = thirdFloorPart end
                end
            end
        end
    end
    return closestTarget
end

local function FloorDetect_getTargetPosition(target)
    if target:IsA("Model") then return FloorDetect_getLaserCenter(target) end
    if target:IsA("BasePart") then
        local pos = target.Position
        if FloorDetect_isSizeClose(target.Size, Vector3.new(17,10,2), 0.01) then
            local zOffset = hrp.Position.X > -410 and 5 or -5
            pos = pos + Vector3.new(0, 0, zOffset)
        end
        return pos
    else return nil end
end

-- Hook ProximityPrompts
local function hookPrompt(prompt)
    local holdStart = 0
    prompt.PromptButtonHoldBegan:Connect(function(player) if player == LocalPlayer then holdStart = tick() end end)
    prompt.PromptButtonHoldEnded:Connect(function(player) if player ~= LocalPlayer or stopMovement then return end local heldTime = tick() - holdStart local tolerance = math.max(0.45, PROMPT_HOLD_TIME * 0.35, networkLag * 1.2) if heldTime + networkLag >= (PROMPT_HOLD_TIME - tolerance) then TaserModule.Enable() isMoving = true if stopMovement then TaserModule.Disable() return end

        local currentY = hrp.Position.Y
        local level = currentY <= 8 and 1 or (currentY <= 24 and 2 or 3)

        local function moveToNearestDeliveryThenPersonal()
            if stopMovement then return end
            local forwardOffset = hrp.CFrame.LookVector * FORWARD_DISTANCE
            local forwardPos = hrp.Position + Vector3.new(forwardOffset.X, 0, forwardOffset.Z)

            local forwardPart = Instance.new("Part")
            forwardPart.Name = "TempForwardTarget"
            forwardPart.Anchored = true
            forwardPart.CanCollide = false
            forwardPart.Size = Vector3.new(1,1,1)
            forwardPart.Transparency = 1
            forwardPart.Position = Vector3.new(forwardPos.X, hrp.Position.Y - 2.8, forwardPos.Z)
            forwardPart.Parent = Workspace

            -- Step 1: move forward
            moveToTarget(forwardPart, function()
                if stopMovement then pcall(function() forwardPart:Destroy() end) return end

                -- Step 2: move to nearest delivery (ground move)
                local nearest = FindNearestDeliveryHitbox()
                if nearest and nearest:IsDescendantOf(Workspace) then
                    moveToTarget(nearest, function()
                        if stopMovement then pcall(function() forwardPart:Destroy() end) return end

                        -- Step 3: move to personal delivery hitbox applying the SAME horizontal offset used in step 1
                        local personal = findMyDeliveryHitbox()
                        if personal and personal:IsDescendantOf(Workspace) then
                            local personalTargetPos = personal.Position + Vector3.new(forwardOffset.X, 0, forwardOffset.Z)

                            -- ENSURE personal temporary target is placed at least the personal safe threshold away
                            local horizVec = Vector3.new(personalTargetPos.X - personal.Position.X, 0, personalTargetPos.Z - personal.Position.Z)
                            local horizDist = horizVec.Magnitude
                            local safeDist = computePersonalSafeThreshold(personal)
                            local chosenOffset
                            if horizDist < 0.001 then
                                -- if almost zero, push it outward from the personal hitbox along our look vector
                                chosenOffset = -hrp.CFrame.LookVector * safeDist
                            else
                                chosenOffset = horizVec.Unit * math.max(horizDist, safeDist)
                            end

                            local personalPart = Instance.new("Part")
                            personalPart.Name = "TempPersonalOffsetTarget"
                            personalPart.Anchored = true
                            personalPart.CanCollide = false
                            personalPart.Size = Vector3.new(1,1,1)
                            personalPart.Transparency = 1
                            personalPart.Position = Vector3.new(personal.Position.X + chosenOffset.X, personal.Position.Y - 2.8, personal.Position.Z + chosenOffset.Z)
                            personalPart.Parent = Workspace

                            moveToTarget(personalPart, function()
                                pcall(function() personalPart:Destroy() end)
                                pcall(function() forwardPart:Destroy() end)
                                if isMoving and not stopMovement then moveToDelivery() end
                            end, false)
                        else
                            pcall(function() forwardPart:Destroy() end)
                            if isMoving and not stopMovement then moveToDelivery() end
                        end
                    end, true)
                else
                    local personal = findMyDeliveryHitbox()
                    if personal and personal:IsDescendantOf(Workspace) then
                        local personalTargetPos = personal.Position + Vector3.new(forwardOffset.X, 0, forwardOffset.Z)

                        -- ENSURE personal temporary target is placed at least the personal safe threshold away
                        local horizVec = Vector3.new(personalTargetPos.X - personal.Position.X, 0, personalTargetPos.Z - personal.Position.Z)
                        local horizDist = horizVec.Magnitude
                        local safeDist = computePersonalSafeThreshold(personal)
                        local chosenOffset
                        if horizDist < 0.001 then
                            chosenOffset = -hrp.CFrame.LookVector * safeDist
                        else
                            chosenOffset = horizVec.Unit * math.max(horizDist, safeDist)
                        end

                        local personalPart = Instance.new("Part")
                        personalPart.Name = "TempPersonalOffsetTarget"
                        personalPart.Anchored = true
                        personalPart.CanCollide = false
                        personalPart.Size = Vector3.new(1,1,1)
                        personalPart.Transparency = 1
                        personalPart.Position = Vector3.new(personal.Position.X + chosenOffset.X, personal.Position.Y - 2.8, personal.Position.Z + chosenOffset.Z)
                        personalPart.Parent = Workspace

                        moveToTarget(personalPart, function()
                            pcall(function() personalPart:Destroy() end)
                            pcall(function() forwardPart:Destroy() end)
                            if isMoving and not stopMovement then moveToDelivery() end
                        end, false)
                    else
                        pcall(function() forwardPart:Destroy() end)
                        moveToDelivery()
                    end
                end
            end, true)
        end

        if level == 1 then
            local nearest = FindNearestDeliveryHitbox()
            if nearest and nearest:IsDescendantOf(Workspace) then
                moveToTarget(nearest, function() if isMoving and not stopMovement then moveToDelivery() end end, true)
            else
                moveToDelivery()
            end
        elseif level == 2 then
            local tgt2 = FloorDetect_getTargetForFloor(2, false)
            if tgt2 then
                moveToTarget(tgt2, function()
                    if stopMovement then return end
                    local exitPart = FloorDetect_getTargetForFloor(2, true)
                    if exitPart then
                        moveToTarget(exitPart, function()
                            if stopMovement then return end
                            moveToNearestDeliveryThenPersonal()
                        end, false)
                    else
                        moveToNearestDeliveryThenPersonal()
                    end
                end, false)
            else
                moveToNearestDeliveryThenPersonal()
            end
        else -- level == 3
            local tgt3 = FloorDetect_getTargetForFloor(3, false)
            if tgt3 then
                moveToTarget(tgt3, function()
                    if stopMovement then return end
                    local tgt2_from3 = FloorDetect_getTargetForFloor(2, true)
                    if tgt2_from3 then
                        moveToTarget(tgt2_from3, function()
                            if stopMovement then return end
                            moveToNearestDeliveryThenPersonal()
                        end, false)
                    else
                        moveToNearestDeliveryThenPersonal()
                    end
                end, false)
            else
                moveToNearestDeliveryThenPersonal()
            end
        end

        -- Keep TaserModule enabled & re-equip while moving
        local reEquipInterval = 2.7
        task.spawn(function()
            while isMoving and not stopMovement do
                if Character and Humanoid and Humanoid.Health > 0 then
                    local tool = TaserModule.FindTool()
                    if tool then
                        if tool.Parent == Backpack then
                            pcall(function() Humanoid:EquipTool(tool) end)
                        end
                    else
                        pcall(function()
                            local packages = ReplicatedStorage:FindFirstChild("Packages")
                            if packages and packages:FindFirstChild("Net") and packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy") then
                                pcall(function() packages.Net["RF/CoinsShopService/RequestBuy"]:InvokeServer(TOOL_NAME) end)
                            end
                        end)
                    end
                end
                task.wait(reEquipInterval)
            end
            TaserModule.Disable()
        end)
    end end)

end

-- hook existing and future prompts
for _, prompt in ipairs(Workspace:GetDescendants()) do
    if prompt:IsA("ProximityPrompt") then hookPrompt(prompt) end
end
Workspace.DescendantAdded:Connect(function(obj)
    if obj:IsA("ProximityPrompt") then hookPrompt(obj) end
end)

-- End of merged Taser script (height = 2.8)
